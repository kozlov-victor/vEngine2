<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-title" content="App name">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="./steamSeaBattle/data/images/bullet.png">
    <link rel="apple-touch-icon" sizes="76x76" href="./steamSeaBattle/data/images/bullet.png">
    <link rel="apple-touch-icon" sizes="120x120" href="./steamSeaBattle/data/images/bullet.png">
    <link rel="apple-touch-icon" sizes="152x152" href="./steamSeaBattle/data/images/bullet.png">

    <style>
        * {
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            outline: none;
        }
        html, body, div, canvas {
            border:none;
            margin: 0;
            padding: 0;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        /* prevent bounce on ios */
        body  {
            position: fixed;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background-color: black;
        }
    </style>

    <script>
        (function() {
            // LH4, LHA (-lh4-) extractor, no crc/sum-checks
            // Erland Ranvinge (erland.ranvinge@gmail.com)
            // Based on a mix of Nobuyasu Suehiro's Java implementation and Simon Howard's C version.
            // Hacked by Matt Westcott to unpack raw LHA streams rather than LZH archive files, and
            //  support lh5 mode

            var LhaArrayReader = function(buffer) {
                this.buffer = buffer;
                this.offset = 0;
                this.subOffset = 7;
            };
            LhaArrayReader.SeekAbsolute = 0;
            LhaArrayReader.SeekRelative = 1;

            LhaArrayReader.prototype.readBits = function(bits) {
                var bitMasks = [1, 2, 4, 8, 16, 32, 64, 128];
                var byt = this.buffer[this.offset];
                var result = 0;

                for (var bitIndex = 0; bitIndex < bits; bitIndex++) {
                    var bit = (byt & bitMasks[this.subOffset]) >> this.subOffset;
                    result <<= 1;
                    result = result | bit;
                    this.subOffset--;
                    if (this.subOffset < 0) {
                        if (this.offset + 1 >= this.buffer.length)
                            return -1;

                        byt = this.buffer[++this.offset];
                        this.subOffset = 7;
                    }
                }
                return result;
            };

            LhaArrayReader.prototype.readUInt8 = function() {
                if (this.offset + 1 >= this.buffer.length)
                    return -1;
                return this.buffer[this.offset++];
            };
            LhaArrayReader.prototype.readUInt16 = function() {
                if (this.offset + 2 >= this.buffer.length)
                    return -1;
                var value =
                    (this.buffer[this.offset] & 0xFF) |
                    ((this.buffer[this.offset+1] << 8) & 0xFF00);
                this.offset += 2;
                return value;
            };
            LhaArrayReader.prototype.readUInt32 = function() {
                if (this.offset + 4 >= this.buffer.length)
                    return -1;
                var value =
                    (this.buffer[this.offset] & 0xFF) |
                    ((this.buffer[this.offset+1] << 8) & 0xFF00) |
                    ((this.buffer[this.offset+2] << 16) & 0xFF0000) |
                    ((this.buffer[this.offset+3] << 24) & 0xFF000000);
                this.offset += 4;
                return value;
            };
            LhaArrayReader.prototype.readString = function(size) {
                if (this.offset + size >= this.buffer.length)
                    return -1;
                var result = '';
                for (var i = 0; i < size; i++)
                    result += String.fromCharCode(this.buffer[this.offset++]);
                return result;
            };

            LhaArrayReader.prototype.readLength = function() {
                var length = this.readBits(3);
                if (length == -1)
                    return -1;

                if (length == 7) {
                    while (this.readBits(1) != 0) {
                        length++;
                    }
                }
                return length;
            };
            LhaArrayReader.prototype.seek = function(offset, mode) {
                switch (mode) {
                    case LhaArrayReader.SeekAbsolute:
                        this.offset = offset;
                        this.subOffset = 7;
                        break;
                    case LhaArrayReader.SeekRelative:
                        this.offset += offset;
                        this.subOffset = 7;
                        break;
                }
            };
            LhaArrayReader.prototype.getPosition = function() {
                return this.offset;
            };

            var LhaArrayWriter = function(size) {
                this.offset = 0;
                this.size = size;
                this.data = new Uint8Array(size);
            };

            LhaArrayWriter.prototype.write = function(data) {
                this.data[this.offset++] = data;
            };

            var LhaTree = function() {};
            LhaTree.LEAF = 1 << 15;

            LhaTree.prototype.setConstant = function(code) {
                this.tree[0] = code | LhaTree.LEAF;
            };

            LhaTree.prototype.expand = function() {
                var endOffset = this.allocated;
                while (this.nextEntry < endOffset) {
                    this.tree[this.nextEntry] = this.allocated;
                    this.allocated += 2;
                    this.nextEntry++;
                }
            };

            LhaTree.prototype.addCodesWithLength = function(codeLengths, codeLength) {
                var done = true;
                for (var i = 0; i < codeLengths.length; i++) {
                    if (codeLengths[i] == codeLength) {
                        var node = this.nextEntry++;
                        this.tree[node] = i | LhaTree.LEAF;
                    } else if (codeLengths[i] > codeLength) {
                        done = false;
                    }
                }
                return done;
            };

            LhaTree.prototype.build = function(codeLengths, size) {
                this.tree = [];
                for (var i = 0; i < size; i++)
                    this.tree[i] = LhaTree.LEAF;

                this.nextEntry = 0;
                this.allocated = 1;
                var codeLength = 0;
                do {
                    this.expand();
                    codeLength++;
                } while (!this.addCodesWithLength(codeLengths, codeLength));
            };

            LhaTree.prototype.readCode = function(reader) {
                var code = this.tree[0];
                while ((code & LhaTree.LEAF) == 0) {
                    var bit = reader.readBits(1);
                    code = this.tree[code + bit];
                }
                return code & ~LhaTree.LEAF;
            };

            var LhaRingBuffer = function(size) {
                this.data = [];
                this.size = size;
                this.offset = 0;
            };

            LhaRingBuffer.prototype.add = function(value) {
                this.data[this.offset] = value;
                this.offset = (this.offset + 1) % this.size;
            };

            LhaRingBuffer.prototype.get = function(offset, length) {
                var pos = this.offset + this.size - offset - 1;
                var result = [];
                for (var i = 0; i < length; i++) {
                    var code = this.data[(pos + i) % this.size];
                    result.push(code);
                    this.add(code);
                }
                return result;
            };

            var LhaReader = function(reader, mode) {
                this.reader = reader;
                this.offsetTree = new LhaTree();
                this.codeTree = new LhaTree();
                if (mode == 'lh4') {
                    this.ringBuffer = new LhaRingBuffer(1 << 13);
                } else if (mode == 'lh5') {
                    this.ringBuffer = new LhaRingBuffer(1 << 14);
                } else {
                    throw "mode must be either lh4 or lh5";
                }
            };

            LhaReader.prototype.readTempTable = function () {
                var reader = this.reader;
                var codeCount = Math.min(reader.readBits(5), 19);
                if (codeCount <= 0) {
                    var constant = reader.readBits(5);
                    this.offsetTree.setConstant(constant);
                    return;
                }
                var codeLengths = [];
                for (var i = 0; i < codeCount; i++) {
                    var codeLength = reader.readLength();
                    codeLengths.push(codeLength);
                    if (i == 2) { // The dreaded special bit that no-one (including me) seems to understand.
                        var length = reader.readBits(2);
                        while (length-- > 0) {
                            codeLengths.push(0);
                            i++;
                        }
                    }
                }
                this.offsetTree.build(codeLengths, 19 * 2);
            };

            LhaReader.prototype.readCodeTable = function() {
                var reader = this.reader;
                var codeCount = Math.min(reader.readBits(9), 510);
                if (codeCount <= 0) {
                    var constant = reader.readBits(9);
                    this.codeTree.setConstant(constant);
                    return;
                }

                var codeLengths = [];
                for (var i = 0; i < codeCount; ) {
                    var code = this.offsetTree.readCode(reader);
                    if (code <= 2) {
                        var skip = 1;
                        if (code == 1)
                            skip = reader.readBits(4) + 3;
                        else if (code == 2)
                            skip = reader.readBits(9) + 20;
                        while (--skip >= 0) {
                            codeLengths.push(0);
                            i++;
                        }
                    } else {
                        codeLengths.push(code - 2);
                        i++;
                    }
                }
                this.codeTree.build(codeLengths, 510 * 2);
            };

            LhaReader.prototype.readOffsetTable = function() {
                var reader = this.reader;
                var codeCount = Math.min(reader.readBits(4), 14);
                if (codeCount <= 0) {
                    var constant = reader.readBits(4);
                    this.offsetTree.setConstant(constant);
                    return;
                } else {
                    var codeLengths = [];
                    for (var i = 0; i < codeCount; i++) {
                        var code = reader.readLength();
                        codeLengths[i] = code;
                    }
                    this.offsetTree.build(codeLengths, 19 * 2);
                }
            };

            LhaReader.prototype.extract = function(offset, originalSize, callback, onerror) {
                this.reader.seek(offset, LhaArrayReader.SeekAbsolute);
                var writer = new LhaArrayWriter(originalSize);
                var that = this;
                function step() { // This step solution was borrowed from ZIP-lib to prevent browser script timeout warnings.
                    console.log('step');
                    if (that.extractBlock(writer)) {
                        if (callback) callback(writer.offset, writer.size);
                        if (writer.offset >= writer.size) {
                            return;
                        }
                        setTimeout(step, 1);
                    }
                }
                setTimeout(step, 1);
                return writer.data;
            };

            LhaReader.prototype.extractBlock = function(writer) {
                var reader = this.reader;
                var blockSize = reader.readBits(16);
                console.log(reader,reader.size);
                if (blockSize <= 0 || reader.offset >= reader.size)
                    return false;

                this.readTempTable();
                this.readCodeTable();
                this.readOffsetTable();

                for (var i = 0; i < blockSize; i++) {
                    var code = this.codeTree.readCode(reader);
                    if (code < 256) {
                        this.ringBuffer.add(code);
                        writer.write(code);
                    } else {
                        var bits = this.offsetTree.readCode(reader);
                        var offset = bits;
                        if (bits >= 2) {
                            var offset = reader.readBits(bits - 1);
                            offset = offset + (1 << (bits - 1));
                        }

                        var length = code - 256 + 3;
                        var chunk = this.ringBuffer.get(offset, length);
                        for (var j in chunk)
                            writer.write(chunk[j]); // TODO: Look at bulk-copying this.
                    }
                }
                return true;
            };

            window.LhaArrayReader = LhaArrayReader;
            window.LhaReader = LhaReader;
        })();
    </script>

</head>

<body>


<script>

    if (window.external && window.external.V_ENGINE_NAVIGATOR) {

        window.console = window.console || new function(e){
            this.log = this.error = function(e){alert(e)}
        };


        var readAsBin = function(url){
            try {
                var jsonArr = window.external.LoadDataAsBin(url);
                return JSON.parse("[" + jsonArr + "]");
            } catch (e) {
                console.error('readAsBin error: ' + url + " " + e);
            }
        };

        var readAsText = function(url){
            try {
                return window.external.LoadDataAsText(url);
            } catch (e) {
                console.error('readAsText error: ' + url + " " + e);
            }
        };

        window.XMLHttpRequest = function(){
            var self = this;
            self.status = 0;
            self.url = '';
            var respHeaders = {};


            self.setRequestHeader = function(key,val){

            };

            self.open = function(method,url){
                self.url = url;
            };
            self.send = function(){
                setTimeout(function(){
                    var currUrl = self.url.split('?')[0];
                    currUrl = currUrl.replace('file:///','');
                    var asBin = (self.responseType==='blob' || self.responseType==='arraybuffer')
                    var resp = asBin?readAsBin(currUrl):readAsText(currUrl);
                    respHeaders['Content-Type'] = asBin?'':'application/json';
                    self.readyState = 4;
                    self.status = 200;
                    self.response = resp;
                    if (resp && resp.toUpperCase) self.responseText = resp;
                    self.onload && self.onload();
                    self.onreadystatechange && self.onreadystatechange();
                },1);
            };
            self.getResponseHeader = function(key){
                return respHeaders[key];
            };

        };

    }

    if ( ![].fill)  {
        Array.prototype.fill = function( value ) {

            var O = Object( this );
            var len = parseInt( O.length, 10 );
            var start = arguments[1];
            var relativeStart = parseInt( start, 10 ) || 0;
            var k = relativeStart < 0
                ? Math.max( len + relativeStart, 0)
                : Math.min( relativeStart, len );
            var end = arguments[2];
            var relativeEnd = end === undefined
                ? len
                : ( parseInt( end)  || 0) ;
            var final = relativeEnd < 0
                ? Math.max( len + relativeEnd, 0 )
                : Math.min( relativeEnd, len );

            for (; k < final; k++) {
                O[k] = value;
            }

            return O;
        };
    }

    if (!window.Number.isNaN) Number.isNaN = function(n){
        return !isFinite(n);
    };

    if (!window.Math.sign) {
        window.Math.sign = function(a) {
            return a>=0?1:-1;
        }
    }

    if (!window.Blob) window.Blob = undefined;

</script>

<script>
    if (!window.Promise) {
        document.write('<script src="./out/polyfills-separate.js"></sc'+'ript>');
    }
</script>

<script>
    document.write('<script src="./out/debug.js?modified='+new Date().getTime()+'"></sc'+'ript>');
</script>

<script>
    (function(){
        function getQueryParams(qs) {
            qs = qs.split('+').join(' ');
            var params = {},
                tokens,
                re = /[?&]?([^=]+)=([^&]*)/g;
            while (tokens = re.exec(qs)) {
                params[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
            }
            return params;
        }
        var name = getQueryParams(document.location.search).name;
        if (!name) throw new Error('name url parameter is not set');
        var scr = document.createElement('script');
        scr.src = './out/'+name+'.js?modified='+new Date().getTime();
        document.body.appendChild(scr);
    })();
</script>
</body>
</html>
